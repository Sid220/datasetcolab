"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/draw/page",{

/***/ "(app-pages-browser)/./hooks/useDraw.tsx":
/*!***************************!*\
  !*** ./hooks/useDraw.tsx ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDraw: function() { return /* binding */ useDraw; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _s = $RefreshSig$();\n\nconst useDraw = (color, imageUrl)=>{\n    _s();\n    const [isDrawing, setIsDrawing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [startPoint, setStartPoint] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [rectangles, setRectangles] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [backgroundImage, setBackgroundImage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Load the background image\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const img = new Image();\n        img.onload = ()=>setBackgroundImage(img);\n        img.src = imageUrl;\n    }, [\n        imageUrl\n    ]);\n    // Draw the background image and rectangles\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(\"2d\");\n        if (!canvas || !ctx) return;\n        // Function to draw the background image\n        const drawBackground = ()=>{\n            if (backgroundImage) {\n                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n            }\n        };\n        // Function to draw a single rectangle\n        const drawRectangle = (rect)=>{\n            ctx.beginPath();\n            ctx.rect(rect.start.x, rect.start.y, rect.end.x - rect.start.x, rect.end.y - rect.start.y);\n            ctx.strokeStyle = color;\n            ctx.lineWidth = 3;\n            ctx.stroke();\n        };\n        // Clear the canvas and redraw everything\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        drawBackground();\n        rectangles.forEach(drawRectangle);\n    }, [\n        rectangles,\n        backgroundImage,\n        color\n    ]); // Redraw when rectangles, backgroundImage, or color changes\n    const onMouseDown = (e)=>{\n        var _canvasRef_current;\n        const rect = (_canvasRef_current = canvasRef.current) === null || _canvasRef_current === void 0 ? void 0 : _canvasRef_current.getBoundingClientRect();\n        if (!rect) return;\n        setStartPoint({\n            x: e.clientX - rect.left,\n            y: e.clientY - rect.top\n        });\n        setIsDrawing(true);\n    };\n    const onMouseMove = (e)=>{\n        if (!isDrawing || !startPoint || !canvasRef.current) return;\n        const rect = canvasRef.current.getBoundingClientRect();\n        const currentPoint = {\n            x: e.clientX - rect.left,\n            y: e.clientY - rect.top\n        };\n        const newRectangles = [\n            ...rectangles,\n            {\n                start: startPoint,\n                end: currentPoint\n            }\n        ];\n        // Temporarily draw the current rectangle\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before redraw\n        if (backgroundImage) {\n            ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);\n        }\n        newRectangles.forEach((rect)=>{\n            ctx.beginPath();\n            ctx.rect(rect.start.x, rect.start.y, rect.end.x - rect.start.x, rect.end.y - rect.start.y);\n            ctx.strokeStyle = color;\n            ctx.lineWidth = 3;\n            ctx.stroke();\n        });\n    };\n    const onMouseUp = ()=>{\n        setIsDrawing(false);\n    };\n    const clear = ()=>{\n        setRectangles([]); // Clears all rectangles but keeps the background image\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        canvas.addEventListener(\"mousemove\", onMouseMove);\n        canvas.addEventListener(\"mouseup\", onMouseUp);\n        return ()=>{\n            canvas.removeEventListener(\"mousemove\", onMouseMove);\n            canvas.removeEventListener(\"mouseup\", onMouseUp);\n        };\n    }, [\n        onMouseMove,\n        onMouseUp,\n        rectangles,\n        startPoint\n    ]);\n    return {\n        canvasRef,\n        onMouseDown,\n        clear\n    };\n};\n_s(useDraw, \"y9LuulgR3xXI9icXCp/odz6QJvw=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1FBQWFXO0lBQU07QUFDekMsRUFBRTtHQXBHVy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZURyYXcudHN4PzY1NjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG4vLyBEZWZpbmUgdHlwZXMgZm9yIGNsYXJpdHkgYW5kIHRvIGF2b2lkIHR5cG9zXG50eXBlIFBvaW50ID0geyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xudHlwZSBSZWN0YW5nbGUgPSB7IHN0YXJ0OiBQb2ludDsgZW5kOiBQb2ludCB9O1xuXG5leHBvcnQgY29uc3QgdXNlRHJhdyA9IChjb2xvcjogc3RyaW5nLCBpbWFnZVVybDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IFtpc0RyYXdpbmcsIHNldElzRHJhd2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzdGFydFBvaW50LCBzZXRTdGFydFBvaW50XSA9IHVzZVN0YXRlPFBvaW50IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtyZWN0YW5nbGVzLCBzZXRSZWN0YW5nbGVzXSA9IHVzZVN0YXRlPFJlY3RhbmdsZVtdPihbXSk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IFtiYWNrZ3JvdW5kSW1hZ2UsIHNldEJhY2tncm91bmRJbWFnZV0gPSB1c2VTdGF0ZTxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gTG9hZCB0aGUgYmFja2dyb3VuZCBpbWFnZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5vbmxvYWQgPSAoKSA9PiBzZXRCYWNrZ3JvdW5kSW1hZ2UoaW1nKTtcbiAgICBpbWcuc3JjID0gaW1hZ2VVcmw7XG4gIH0sIFtpbWFnZVVybF0pO1xuXG4gIC8vIERyYXcgdGhlIGJhY2tncm91bmQgaW1hZ2UgYW5kIHJlY3RhbmdsZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBjdHggPSBjYW52YXM/LmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKCFjYW52YXMgfHwgIWN0eCkgcmV0dXJuO1xuXG4gICAgLy8gRnVuY3Rpb24gdG8gZHJhdyB0aGUgYmFja2dyb3VuZCBpbWFnZVxuICAgIGNvbnN0IGRyYXdCYWNrZ3JvdW5kID0gKCkgPT4ge1xuICAgICAgaWYgKGJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmRJbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRnVuY3Rpb24gdG8gZHJhdyBhIHNpbmdsZSByZWN0YW5nbGVcbiAgICBjb25zdCBkcmF3UmVjdGFuZ2xlID0gKHJlY3Q6IFJlY3RhbmdsZSkgPT4ge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnJlY3QoXG4gICAgICAgIHJlY3Quc3RhcnQueCxcbiAgICAgICAgcmVjdC5zdGFydC55LFxuICAgICAgICByZWN0LmVuZC54IC0gcmVjdC5zdGFydC54LFxuICAgICAgICByZWN0LmVuZC55IC0gcmVjdC5zdGFydC55XG4gICAgICApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgLy8gQ2xlYXIgdGhlIGNhbnZhcyBhbmQgcmVkcmF3IGV2ZXJ5dGhpbmdcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgZHJhd0JhY2tncm91bmQoKTtcbiAgICByZWN0YW5nbGVzLmZvckVhY2goZHJhd1JlY3RhbmdsZSk7XG5cbiAgfSwgW3JlY3RhbmdsZXMsIGJhY2tncm91bmRJbWFnZSwgY29sb3JdKTsgLy8gUmVkcmF3IHdoZW4gcmVjdGFuZ2xlcywgYmFja2dyb3VuZEltYWdlLCBvciBjb2xvciBjaGFuZ2VzXG5cbiAgY29uc3Qgb25Nb3VzZURvd24gPSAoZTogUmVhY3QuTW91c2VFdmVudDxIVE1MQ2FudmFzRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzUmVmLmN1cnJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghcmVjdCkgcmV0dXJuO1xuICAgIHNldFN0YXJ0UG9pbnQoeyB4OiBlLmNsaWVudFggLSByZWN0LmxlZnQsIHk6IGUuY2xpZW50WSAtIHJlY3QudG9wIH0pO1xuICAgIHNldElzRHJhd2luZyh0cnVlKTtcbiAgfTtcblxuICBjb25zdCBvbk1vdXNlTW92ZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKCFpc0RyYXdpbmcgfHwgIXN0YXJ0UG9pbnQgfHwgIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhc1JlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGN1cnJlbnRQb2ludDogUG9pbnQgPSB7IHg6IGUuY2xpZW50WCAtIHJlY3QubGVmdCwgeTogZS5jbGllbnRZIC0gcmVjdC50b3AgfTtcbiAgICBjb25zdCBuZXdSZWN0YW5nbGVzID0gWy4uLnJlY3RhbmdsZXMsIHsgc3RhcnQ6IHN0YXJ0UG9pbnQsIGVuZDogY3VycmVudFBvaW50IH1dO1xuICAgIFxuICAgIC8vIFRlbXBvcmFyaWx5IGRyYXcgdGhlIGN1cnJlbnQgcmVjdGFuZ2xlXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKCFjdHgpIHJldHVybjtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7IC8vIENsZWFyIGNhbnZhcyBiZWZvcmUgcmVkcmF3XG4gICAgaWYgKGJhY2tncm91bmRJbWFnZSkge1xuICAgICAgY3R4LmRyYXdJbWFnZShiYWNrZ3JvdW5kSW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfVxuICAgIG5ld1JlY3RhbmdsZXMuZm9yRWFjaChyZWN0ID0+IHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5yZWN0KHJlY3Quc3RhcnQueCwgcmVjdC5zdGFydC55LCByZWN0LmVuZC54IC0gcmVjdC5zdGFydC54LCByZWN0LmVuZC55IC0gcmVjdC5zdGFydC55KTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25Nb3VzZVVwID0gKCkgPT4ge1xuICAgIHNldElzRHJhd2luZyhmYWxzZSk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXIgPSAoKSA9PiB7XG4gICAgc2V0UmVjdGFuZ2xlcyhbXSk7IC8vIENsZWFycyBhbGwgcmVjdGFuZ2xlcyBidXQga2VlcHMgdGhlIGJhY2tncm91bmQgaW1hZ2VcbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm47XG5cbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUgYXMgYW55KTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCBhcyBhbnkpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSBhcyBhbnkpO1xuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXAgYXMgYW55KTtcbiAgICB9O1xuICB9LCBbb25Nb3VzZU1vdmUsIG9uTW91c2VVcCwgcmVjdGFuZ2xlcywgc3RhcnRQb2ludF0pO1xuXG4gIHJldHVybiB7IGNhbnZhc1JlZiwgb25Nb3VzZURvd24sIGNsZWFyIH07XG59OyJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZURyYXciLCJjb2xvciIsImltYWdlVXJsIiwiaXNEcmF3aW5nIiwic2V0SXNEcmF3aW5nIiwic3RhcnRQb2ludCIsInNldFN0YXJ0UG9pbnQiLCJyZWN0YW5nbGVzIiwic2V0UmVjdGFuZ2xlcyIsImNhbnZhc1JlZiIsImJhY2tncm91bmRJbWFnZSIsInNldEJhY2tncm91bmRJbWFnZSIsImltZyIsIkltYWdlIiwib25sb2FkIiwic3JjIiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJkcmF3QmFja2dyb3VuZCIsImRyYXdJbWFnZSIsIndpZHRoIiwiaGVpZ2h0IiwiZHJhd1JlY3RhbmdsZSIsInJlY3QiLCJiZWdpblBhdGgiLCJzdGFydCIsIngiLCJ5IiwiZW5kIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJjbGVhclJlY3QiLCJmb3JFYWNoIiwib25Nb3VzZURvd24iLCJlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImxlZnQiLCJjbGllbnRZIiwidG9wIiwib25Nb3VzZU1vdmUiLCJjdXJyZW50UG9pbnQiLCJuZXdSZWN0YW5nbGVzIiwib25Nb3VzZVVwIiwiY2xlYXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useDraw.tsx\n"));

/***/ })

});